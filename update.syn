(* Needs to be generated *)
(* type path = A | B | C | D | E | F | G *)

(* Needs to be generated *)
(* type hash = H1 | H2 | H3 *)

type resource =
  | RFile of path * hash * bool (* force? *)
  | REnsureFile of path * hash
  | RAbsentPath of path * bool (* force? *)
  | RDirectory of path

type resourcelist =
  | RListNil
  | RListCons of resource * resourcelist

type stat =
  | IsFile
  | IsDir
  | DoesNotExist

type filestate =
  | SFile of hash
  | SDir
  | SDoesNotExist

type pred =
  | True
  | False
  | And of pred * pred
  | Or of pred * pred
  | Not of pred
  | TestFileState of path * stat
  | ITE of pred * pred * pred

type expr =
  | If of pred * expr * expr
  | Mkdir of path
  | CreateFile of path * hash
  | Seq of expr * expr
  | Rm of path
  | Cp of path * path
  | Skip

type state =
  | Error
  | Ok of (path, filestate) array

type parentresult =
  | NoParent
  | Parent of path

(* TODO(arjun): Must be generated *)
(* let parent (p: path) = NoParent in *)

let rec compileResource(r : resource) : expr = match r with
  | REnsureFile(p, c) =>
    Seq (If(TestFileState(p, IsFile), Rm(p), Skip), CreateFile(p, c))
  | RFile(p, c, force) =>
    (match force with
     | false =>
       If(TestFileState(p, IsFile), Seq(Rm(p), CreateFile(p, c)),
          If(TestFileState(p, DoesNotExist),
             CreateFile(p, c),
             Skip))
     | true =>
       Seq(If(TestFileState(p, IsDir),
              Rm(p),
              If(TestFileState(p, IsFile), Rm(p), Skip)),
           CreateFile(p, c)))
  | RAbsentPath(p, force) =>
    (match force with
     | false => If(TestFileState(p, IsFile), Rm(p), Skip)
     | true =>
       If(TestFileState(p, IsDir),
          Rm(p),
          If(TestFileState(p, IsFile),
             Rm(p),
             Skip)))
  | RDirectory(p) =>
      If(TestFileState(p, IsDir),
         Skip,
         If(TestFileState(p, IsFile),
            Seq(Rm(p), Mkdir(p)),
            Mkdir(p))) in

let rec evalpred (fs : (path, filestate) array) (p : pred) : bool = match p with
  | True => true
  | False => false
  | And (p0, p1) => (evalpred fs p0) && (evalpred fs p1)
  | Or (p0, p1) => (evalpred fs p0) || (evalpred fs p1)
  | Not (p) => ! (evalpred fs p)
  | TestFileState (path, stat) =>
    (match select(fs, path) with
     | SDir => (match stat with | IsDir => true | _ => false)
     | SDoesNotExist => (match stat with | DoesNotExist => true | _ => false)
     | SFile (h) => (match stat with | IsFile => true | _ => false))
  | ITE (a, b, c) => (match (evalpred fs a) with
            		      | true => evalpred fs b
            		      | false => evalpred fs c) in

let isfile (fs : (path, filestate) array) (p : path)  =
  match select(fs, p) with
  | SFile (h) => true
  | _ => false in

let isdir (fs : (path, filestate) array) (p : path) =
  match select(fs, p) with
  | SDir => true
  | _ => false in

let doesnotexist (fs : (path, filestate) array) (p : path) =
  match select(fs, p) with
  | SDoesNotExist => true
  | _ => false in

let isparentdir (fs : (path, filestate) array) (p: path) =  match parent p with
  | NoParent => false
  | Parent (parent) => isdir fs parent in

let rec evalexpr (fs : (path, filestate) array) (expr : expr) : state =
  match expr with
  | Skip => Ok (fs)
  | If (pred, texpr, fexpr) =>
    (match evalpred fs pred with
		   | true => evalexpr fs texpr
			 | false => evalexpr fs fexpr)
  | Mkdir (path) =>
   (* TODO(arjun): also check parent *)
   (match (evalpred fs TestFileState(path, DoesNotExist)) with
			 | true => Ok (store(fs, path, SDir))
			 | false => Error)
  | CreateFile (p, h) =>
   (match doesnotexist fs p && isparentdir fs p with
			  | true => Ok (store(fs, p, SFile (h)))
			  | false => Error)
  | Seq (e1, e2) =>
    (match evalexpr fs e1 with
     | Ok (fs1) => evalexpr fs1 e2
     | Error => Error)
  | Rm (p) =>
    (match isfile fs p with
     | true => Ok (store(fs, p, SDoesNotExist))
     | false => Error)
  | Cp (src, dst) =>
    (* TODO(arjun): preconditions *)
    (match doesnotexist fs dst && isparentdir fs dst with
     | true =>
       (match select(fs, src) with
        | SFile(h) => Ok (store(fs, dst, SFile (h)))
        | _ => Error)
		 | false => Error)
in

let genresource (n : num) = match ?? % 4 with
  | 0 => RFile (genpath 0, genhash 0, ??)
  | 1 => REnsureFile (genpath 0, genhash 0)
  | 2 => RAbsentPath (genpath 0, ??)
  | _ => RDirectory (genpath 0)

in

let rec genresourcelist (depth : num) : resourcelist= match depth with
  | 0 => RListNil
  | _ => (match (?? : bool) with
          | true => RListNil
          | false => RListCons (genresource 0, genresourcelist (depth - 1)))

in

let genfilestate (n : num) = match ?? % 3 with
  | 0 => SDir
  | 1 => SDoesNotExist
  | _ => SFile (genhash 0)

in

let rec evalresources (fs : (path, filestate) array) (lst : resourcelist) : state = match lst with
  | RListNil => Ok (fs)
  | RListCons (r, rest) =>
    (match evalexpr fs (compileResource r) with
     | Ok (fs2) => evalresources fs2 rest
     | Error => Error)

in

let evalunwrap (st : state) (lst : resourcelist)  = match st with
  | Error => Error
  | Ok (fs) => evalresources fs lst

in

let unwrapstate (st : state) (default : (path, filestate) array) = match st with
  | Ok (fs) => fs
  | Error => default

in

let filestateeq (f1 : filestate) (f2 : filestate) = match f1 with
  | SFile (h1) => (match f2 with | SFile (h2) => hasheq h1 h2 | _ => false)
  | SDir => (match f2 with | SDir => true | _ => false)
  | SDoesNotExist => (match f2 with | SDoesNotExist => true | _ => false)

in

0